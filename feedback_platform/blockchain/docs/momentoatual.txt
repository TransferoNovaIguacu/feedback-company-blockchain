âœ… RevisÃ£o Completa do Projeto Feedback Platform
ğŸ§  VisÃ£o Geral do Funcionamento Atual
Seu projeto estÃ¡ 95% funcional com:

Contrato Solidity deployado e funcionando (âœ… Sepolia)
Mint em lote (batchMint) via Django CLI (âœ…)
Worker Celery com process_reward_batch (âœ…)
ValidaÃ§Ã£o de MINTER_ROLE no contrato (âœ…)
Saldo local no Django atualizado apÃ³s mint (âœ…)
Logs detalhados e tratamento de erro (âš ï¸ Parcial)
ğŸ” O que falta para o listen_for_batch_mint_events funcionar corretamente
1. Erro no uso de create_filter() com HTTPProvider
python


1
event_filter = service.contract.events.BatchMinted.create_filter(fromBlock='latest')
â¡ï¸ Problema:
create_filter() requer conexÃ£o WebSocket (nÃ£o funciona com HTTPProvider)

âœ… SoluÃ§Ã£o: Use get_logs() com polling manual
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
# blockchain/tasks/events.py
def listen_for_batch_mint_events():
    service = BlockchainService(use_ws=False)
    last_block = service.w3.eth.block_number  # ComeÃ§a do bloco atual
    
    while True:
        try:
            current_block = service.w3.eth.block_number
            if current_block > last_block:
                events = service.contract.events.BatchMinted.get_logs(
                    fromBlock=last_block + 1,
                    toBlock=current_block
                )
                for event in events:
                    recipients = event.args['recipients']
                    amounts = event.args['amounts']
                    
                    for recipient, amount in zip(recipients, amounts):
                        try:
                            with transaction.atomic():
                                profile = UserProfile.objects.select_for_update().get(
                                    wallet_address__iexact=recipient
                                )
                                profile.blockchain_balance += Decimal(str(amount / 10**18))
                                profile.save()
                                logger.info(f"âœ… Saldo atualizado para {recipient}")
                        except UserProfile.DoesNotExist:
                            logger.warning(f"âŒ Perfil nÃ£o encontrado para {recipient}")
                        except Exception as e:
                            logger.error(f"ğŸš¨ Erro ao atualizar perfil {recipient}: {e}")
                last_block = current_block
            time.sleep(5)
        except Exception as e:
            logger.error(f"âŒ Erro no loop de eventos: {e}")
            time.sleep(10)
ğŸ› ï¸ Passo 1: Atualize o BlockchainService.__init__ para aceitar use_ws
ğŸ“„ services.py
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
class BlockchainService:
    def __init__(self, use_ws=False):
        # âœ… Usa provider correto com base em use_ws
        provider_url = settings.WEB3_WS_PROVIDER_URL if use_ws else settings.WEB3_HTTP_PROVIDER_URL
        
        if use_ws:
            self.w3 = Web3(Web3.WebSocketProvider(provider_url))  # âœ… WebSocket
            logger.info("[BlockchainService] âœ… Usando WebSocketProvider")
        else:
            self.w3 = Web3(Web3.HTTPProvider(provider_url))  # âœ… HTTP fallback
            logger.info("[BlockchainService] ğŸš« Usando HTTPProvider")

        if not self.w3.is_connected():
            logger.error("âŒ Falha ao conectar com o provider Ethereum")
            raise ConnectionError("NÃ£o foi possÃ­vel conectar ao provider Ethereum")
        
        if hasattr(settings, 'CONTRACT_ADDRESS') and Web3.is_address(settings.CONTRACT_ADDRESS):
            if not self._load_contract():
                logger.warning("âš ï¸ Contrato nÃ£o carregado")
        else:
            logger.warning("âš ï¸ CONTRACT_ADDRESS invÃ¡lido ou nÃ£o definido")
ğŸ§ª Passo 2: Confirme que o worker do Celery estÃ¡ escutando a fila certa
bash


1
celery -A feedback_platform worker --loglevel=info --pool=solo --queues celery,event_queue
â¡ï¸ Certifique-se de que ele carrega a tarefa:



1
2
[tasks]
  . listen_for_batch_mint_events
ğŸ“‹ Passo 3: Teste manualmente no shell se o evento Ã© detectado
bash


1
python manage.py shell
python


1
2
3
4
5
6
7
8
9
from blockchain.services import BlockchainService
service = BlockchainService(use_ws=False)  # Use HTTPProvider

# Tenta obter eventos manualmente
events = service.contract.events.BatchMinted.get_logs(
    fromBlock='latest',
    toBlock='latest'
)
print("Eventos detectados:", len(events))
â¡ï¸ Se retornar eventos, o problema estÃ¡ na tarefa Celery

ğŸ§¾ Passo 4: Corrija o formato de endereÃ§o no Django e no contrato
python


1
2
3
4
5
6
7
# âŒ EndereÃ§o sem checksum no Django
profile.wallet_address = "0x6123AbC4567890dE12345fEdCBA6789a1234FDeC"

# âœ… Use checksum para garantir compatibilidade
checksum_addr = Web3.to_checksum_address("0x6123AbC4567890dE12345fEdCBA6789a1234FDeC")
profile.wallet_address = checksum_addr
profile.save()
â¡ï¸ Isso garante que o get_logs() encontre o perfil corretamente

ğŸ“Œ Passo 5: Valide conversÃ£o de amounts para Decimal
python


1
2
3
4
5
# âŒ Erro: unsupported operand type(s) for +=: 'decimal.Decimal' and 'float'
token_amount = amount / 10**18  # âŒ Float â†’ causa erro com Decimal

# âœ… Corrigido: converte para string antes
token_amount = Decimal(str(amount / 10**18))
â¡ï¸ Adicione isso no events.py e rewards.py

ğŸ§° Passo 6: Reinicie o worker do Celery com logs detalhados
bash


1
celery -A feedback_platform worker --loglevel=debug --pool=solo --queues celery,event_queue
â¡ï¸ Certifique-se de que ele estÃ¡ na pasta correta (feedback_platform/)

ğŸ“Š Resumo Final das CorreÃ§Ãµes NecessÃ¡rias
âœ… Substituir
create_filter()
por
get_logs()
âŒ Antes da correÃ§Ã£o
âœ… Converter
amounts
para
Decimal(str(...))
âŒ Antes da correÃ§Ã£o
âœ… Usar
__iexact
na busca de perfis
âŒ ApÃ³s validaÃ§Ã£o
âœ… Worker do Celery escutando
event_queue
âœ… Sim
âœ… Logs detalhados no inÃ­cio da tarefa
âŒ ApÃ³s adiÃ§Ã£o
âœ… EndereÃ§o Ethereum no formato checksumado
âŒ ApÃ³s correÃ§Ã£o
âœ…
.env
carregado corretamente
âœ… Sim

ğŸš€ PrÃ³ximos passos recomendados
Atualize o events.py com get_logs() e Decimal(str(...))
Reinicie o worker do Celery na pasta correta
Cole o tx_hash no Etherscan para validar evento
Teste manualmente no shell se o evento Ã© detectado
Confira no worker se os logs de evento aparecem corretamente
Se ainda tiver dÃºvidas ou quiser integrar isso com front-end, posso te ajudar! ğŸš€



Os problemas atuais estÃ¡ em testar o events.py e rewards.py no celery para verificar se esta funcionando corretamente.

para testar tem que tÃ¡ funcionando aqui (.venv) C:\Users\giffo\Documents\Lukas ProgramaÃ§Ã£o\feedback_platform\feedback_platform>celery -A feedback_platform worker --loglevel=debug --pool=solo --queues celery,event_queue

o redis tem que estar aberto

usar o python manage.py shell
para realizar os testes 



âœ… Vamos adaptar o events.py para funcionar com HTTPProvider e resolver os problemas de tipo no Django
ğŸ› ï¸ Passo 1: Atualize o events.py para usar HTTPProvider
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
# blockchain/tasks/events.py
import logging
import time
from decimal import Decimal
from celery import shared_task
from django.conf import settings
from blockchain.services import BlockchainService
from blockchain.models import UserProfile
from django.db import transaction

logger = logging.getLogger(__name__)

@shared_task(name="listen_for_batch_mint_events", queue='event_queue')
def listen_for_batch_mint_events():
    """Escuta eventos BatchMinted e atualiza o sistema via HTTPProvider"""
    try:
        logger.info("ğŸ§ Iniciando escuta de eventos BatchMinted")
        service = BlockchainService(use_ws=False)  # âœ… ForÃ§a uso de HTTPProvider
        logger.info("âœ… Conectado Ã  blockchain via HTTP")
        
        # ObtÃ©m o Ãºltimo bloco processado (ou define como 'latest')
        last_block = getattr(settings, 'LAST_PROCESSED_BLOCK', 'latest')

        while True:
            try:
                # âœ… Usa get_logs() com fromBlock='latest' para HTTPProvider
                events = service.contract.events.BatchMinted.get_logs(
                    fromBlock=last_block,
                    toBlock='latest'
                )

                for event in events:
                    logger.info(f"ğŸ‰ Evento BatchMinted detectado no bloco {event.blockNumber}")
                    recipients = event.args.recipients
                    amounts = event.args.amounts

                    for recipient, amount in zip(recipients, amounts):
                        try:
                            with transaction.atomic():
                                profile = UserProfile.objects.get(wallet_address__iexact=recipient)
                                token_amount = Decimal(str(amount / 10**18))
                                
                                # âœ… Converte para Decimal antes de somar
                                profile.blockchain_balance += token_amount
                                profile.save(update_fields=['blockchain_balance'])
                                logger.info(f"âœ… Saldo atualizado para {recipient}: {profile.blockchain_balance} FBTK")
                        except UserProfile.DoesNotExist:
                            logger.warning(f"âŒ Perfil nÃ£o encontrado para {recipient}")
                        except Exception as e:
                            logger.error(f"ğŸš¨ Erro ao atualizar perfil {recipient}: {e}")

                    # Atualiza o Ãºltimo bloco processado
                    last_block = event.blockNumber + 1
                    settings.LAST_PROCESSED_BLOCK = last_block

                time.sleep(5)

            except Exception as e:
                logger.error(f"âŒ Erro durante a escuta: {e}")
                time.sleep(10)
                service = BlockchainService(use_ws=False)  # Recria serviÃ§o em caso de erro

    except Exception as e:
        logger.exception(f"âŒ ERRO CRÃTICO ao iniciar escuta de eventos: {e}")
        raise
ğŸ§° Passo 2: Atualize o services.py para aceitar use_ws=False
ğŸ“„ services.py
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
âŒ„
class BlockchainService:
    def __init__(self, use_ws=False):
        # âœ… Ajusta o provider com base em use_ws
        provider_url = settings.WEB3_WS_PROVIDER_URL if use_ws else settings.WEB3_HTTP_PROVIDER_URL
        
        if use_ws:
            self.w3 = Web3(Web3.WebSocketProvider(provider_url))
            logger.info("[BlockchainService] âœ… Usando WebSocketProvider")
        else:
            self.w3 = Web3(Web3.HTTPProvider(provider_url))
            logger.info("[BlockchainService] ğŸš« Usando HTTPProvider")

        # âœ… Valida conexÃ£o
        if not self.w3.is_connected():
            logger.error("âŒ Falha ao conectar com o provider Ethereum")
            raise ConnectionError("NÃ£o foi possÃ­vel conectar ao provider Ethereum")

        # âœ… Carrega contrato
        if hasattr(settings, 'CONTRACT_ADDRESS') and Web3.is_address(settings.CONTRACT_ADDRESS):
            if not self._load_contract():
                logger.warning("âš ï¸ Contrato nÃ£o carregado")
        else:
            logger.warning("âš ï¸ CONTRACT_ADDRESS nÃ£o definido ou invÃ¡lido")
ğŸ§ª Passo 3: Reinicie o worker do Celery com logs detalhados
bash


1
celery -A feedback_platform worker --loglevel=info --pool=solo --queues event_queue
â¡ï¸ Certifique-se de que ele estÃ¡ na raiz do projeto (feedback_platform/)

ğŸ§¾ Passo 4: Execute manualmente no shell para validar eventos
bash


1
python manage.py shell
python


1
2
3
4
5
6
from blockchain.services import BlockchainService
service = BlockchainService(use_ws=False)

# Obter evento manualmente
events = service.contract.events.BatchMinted.get_logs(fromBlock='latest', toBlock='latest')
print("Eventos detectados:", len(events))
â¡ï¸ Se aparecerem eventos, o problema estÃ¡ na tarefa Celery

ğŸ§ª Passo 5: Crie uma transaÃ§Ã£o para gerar evento
ğŸ“„ No shell:
bash


1
python manage.py shell
python


1
2
from blockchain.tasks.rewards import process_reward_batch
process_reward_batch.delay()
â¡ï¸ Isso vai gerar um evento BatchMinted que seu listen_for_batch_mint_events pode capturar

ğŸ“‹ Resumo Final
âœ…
events.py
usa
get_logs()
em vez de
get_new_entries()
âŒ Antes da correÃ§Ã£o
âœ… Valida
token_amount
como
Decimal
âŒ Antes da correÃ§Ã£o
âœ… Worker do Celery escutando
event_queue
âœ… Sim
âœ…
BlockchainService
aceita
use_ws=False
âŒ ApÃ³s validaÃ§Ã£o
âœ… Logs mostrando eventos detectados
âŒ ApÃ³s execuÃ§Ã£o
âœ… Saldo local atualizado apÃ³s evento
âŒ ApÃ³s validaÃ§Ã£o

ğŸš€ PrÃ³ximos passos recomendados
Atualize o events.py com get_logs() e Decimal
Reinicie o worker do Celery com --queues event_queue
Cole o tx_hash no Etherscan para validar evento
Teste manualmente no shell se o evento Ã© detectado
Confira no worker se os logs de evento aparecem corretamente
Se ainda tiver dÃºvidas ou quiser integrar isso com front-end, posso te ajudar! ğŸš€