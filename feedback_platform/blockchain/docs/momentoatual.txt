‚úÖ Revis√£o Completa do Projeto Feedback Platform
üß† Vis√£o Geral do Funcionamento Atual
Seu projeto est√° 95% funcional com:

Contrato Solidity deployado e funcionando (‚úÖ Sepolia)
Mint em lote (batchMint) via Django CLI (‚úÖ)
Worker Celery com process_reward_batch (‚úÖ)
Valida√ß√£o de MINTER_ROLE no contrato (‚úÖ)
Saldo local no Django atualizado ap√≥s mint (‚úÖ)
Logs detalhados e tratamento de erro (‚ö†Ô∏è Parcial)
üîç O que falta para o listen_for_batch_mint_events funcionar corretamente
1. Erro no uso de create_filter() com HTTPProvider
python


1
event_filter = service.contract.events.BatchMinted.create_filter(fromBlock='latest')
‚û°Ô∏è Problema:
create_filter() requer conex√£o WebSocket (n√£o funciona com HTTPProvider)

‚úÖ Solu√ß√£o: Use get_logs() com polling manual
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
# blockchain/tasks/events.py
def listen_for_batch_mint_events():
    service = BlockchainService(use_ws=False)
    last_block = service.w3.eth.block_number  # Come√ßa do bloco atual
    
    while True:
        try:
            current_block = service.w3.eth.block_number
            if current_block > last_block:
                events = service.contract.events.BatchMinted.get_logs(
                    fromBlock=last_block + 1,
                    toBlock=current_block
                )
                for event in events:
                    recipients = event.args['recipients']
                    amounts = event.args['amounts']
                    
                    for recipient, amount in zip(recipients, amounts):
                        try:
                            with transaction.atomic():
                                profile = UserProfile.objects.select_for_update().get(
                                    wallet_address__iexact=recipient
                                )
                                profile.blockchain_balance += Decimal(str(amount / 10**18))
                                profile.save()
                                logger.info(f"‚úÖ Saldo atualizado para {recipient}")
                        except UserProfile.DoesNotExist:
                            logger.warning(f"‚ùå Perfil n√£o encontrado para {recipient}")
                        except Exception as e:
                            logger.error(f"üö® Erro ao atualizar perfil {recipient}: {e}")
                last_block = current_block
            time.sleep(5)
        except Exception as e:
            logger.error(f"‚ùå Erro no loop de eventos: {e}")
            time.sleep(10)
üõ†Ô∏è Passo 1: Atualize o BlockchainService.__init__ para aceitar use_ws
üìÑ services.py
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
class BlockchainService:
    def __init__(self, use_ws=False):
        # ‚úÖ Usa provider correto com base em use_ws
        provider_url = settings.WEB3_WS_PROVIDER_URL if use_ws else settings.WEB3_HTTP_PROVIDER_URL
        
        if use_ws:
            self.w3 = Web3(Web3.WebSocketProvider(provider_url))  # ‚úÖ WebSocket
            logger.info("[BlockchainService] ‚úÖ Usando WebSocketProvider")
        else:
            self.w3 = Web3(Web3.HTTPProvider(provider_url))  # ‚úÖ HTTP fallback
            logger.info("[BlockchainService] üö´ Usando HTTPProvider")

        if not self.w3.is_connected():
            logger.error("‚ùå Falha ao conectar com o provider Ethereum")
            raise ConnectionError("N√£o foi poss√≠vel conectar ao provider Ethereum")
        
        if hasattr(settings, 'CONTRACT_ADDRESS') and Web3.is_address(settings.CONTRACT_ADDRESS):
            if not self._load_contract():
                logger.warning("‚ö†Ô∏è Contrato n√£o carregado")
        else:
            logger.warning("‚ö†Ô∏è CONTRACT_ADDRESS inv√°lido ou n√£o definido")
üß™ Passo 2: Confirme que o worker do Celery est√° escutando a fila certa
bash


1
celery -A feedback_platform worker --loglevel=info --pool=solo --queues celery,event_queue
‚û°Ô∏è Certifique-se de que ele carrega a tarefa:



1
2
[tasks]
  . listen_for_batch_mint_events
üìã Passo 3: Teste manualmente no shell se o evento √© detectado
bash


1
python manage.py shell
python


1
2
3
4
5
6
7
8
9
from blockchain.services import BlockchainService
service = BlockchainService(use_ws=False)  # Use HTTPProvider

# Tenta obter eventos manualmente
events = service.contract.events.BatchMinted.get_logs(
    fromBlock='latest',
    toBlock='latest'
)
print("Eventos detectados:", len(events))
‚û°Ô∏è Se retornar eventos, o problema est√° na tarefa Celery

üßæ Passo 4: Corrija o formato de endere√ßo no Django e no contrato
python


1
2
3
4
5
6
7
# ‚ùå Endere√ßo sem checksum no Django
profile.wallet_address = "0x6123AbC4567890dE12345fEdCBA6789a1234FDeC"

# ‚úÖ Use checksum para garantir compatibilidade
checksum_addr = Web3.to_checksum_address("0x6123AbC4567890dE12345fEdCBA6789a1234FDeC")
profile.wallet_address = checksum_addr
profile.save()
‚û°Ô∏è Isso garante que o get_logs() encontre o perfil corretamente

üìå Passo 5: Valide convers√£o de amounts para Decimal
python


1
2
3
4
5
# ‚ùå Erro: unsupported operand type(s) for +=: 'decimal.Decimal' and 'float'
token_amount = amount / 10**18  # ‚ùå Float ‚Üí causa erro com Decimal

# ‚úÖ Corrigido: converte para string antes
token_amount = Decimal(str(amount / 10**18))
‚û°Ô∏è Adicione isso no events.py e rewards.py

üß∞ Passo 6: Reinicie o worker do Celery com logs detalhados
bash


1
celery -A feedback_platform worker --loglevel=debug --pool=solo --queues celery,event_queue
‚û°Ô∏è Certifique-se de que ele est√° na pasta correta (feedback_platform/)

üìä Resumo Final das Corre√ß√µes Necess√°rias
‚úÖ Substituir
create_filter()
por
get_logs()
‚ùå Antes da corre√ß√£o
‚úÖ Converter
amounts
para
Decimal(str(...))
‚ùå Antes da corre√ß√£o
‚úÖ Usar
__iexact
na busca de perfis
‚ùå Ap√≥s valida√ß√£o
‚úÖ Worker do Celery escutando
event_queue
‚úÖ Sim
‚úÖ Logs detalhados no in√≠cio da tarefa
‚ùå Ap√≥s adi√ß√£o
‚úÖ Endere√ßo Ethereum no formato checksumado
‚ùå Ap√≥s corre√ß√£o
‚úÖ
.env
carregado corretamente
‚úÖ Sim

üöÄ Pr√≥ximos passos recomendados
Atualize o events.py com get_logs() e Decimal(str(...))
Reinicie o worker do Celery na pasta correta
Cole o tx_hash no Etherscan para validar evento
Teste manualmente no shell se o evento √© detectado
Confira no worker se os logs de evento aparecem corretamente
Se ainda tiver d√∫vidas ou quiser integrar isso com front-end, posso te ajudar! üöÄ



Os problemas atuais est√° em testar o events.py e rewards.py no celery para verificar se esta funcionando corretamente.

para testar tem que t√° funcionando aqui (.venv) C:\Users\giffo\Documents\Lukas Programa√ß√£o\feedback_platform\feedback_platform>celery -A feedback_platform worker --loglevel=debug --pool=solo --queues celery,event_queue

o redis tem que estar aberto

usar o python manage.py shell
para realizar os testes 



‚úÖ Vamos adaptar o events.py para funcionar com HTTPProvider e resolver os problemas de tipo no Django
üõ†Ô∏è Passo 1: Atualize o events.py para usar HTTPProvider
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
# blockchain/tasks/events.py
import logging
import time
from decimal import Decimal
from celery import shared_task
from django.conf import settings
from blockchain.services import BlockchainService
from blockchain.models import UserProfile
from django.db import transaction

logger = logging.getLogger(__name__)

@shared_task(name="listen_for_batch_mint_events", queue='event_queue')
def listen_for_batch_mint_events():
    """Escuta eventos BatchMinted e atualiza o sistema via HTTPProvider"""
    try:
        logger.info("üéß Iniciando escuta de eventos BatchMinted")
        service = BlockchainService(use_ws=False)  # ‚úÖ For√ßa uso de HTTPProvider
        logger.info("‚úÖ Conectado √† blockchain via HTTP")
        
        # Obt√©m o √∫ltimo bloco processado (ou define como 'latest')
        last_block = getattr(settings, 'LAST_PROCESSED_BLOCK', 'latest')

        while True:
            try:
                # ‚úÖ Usa get_logs() com fromBlock='latest' para HTTPProvider
                events = service.contract.events.BatchMinted.get_logs(
                    fromBlock=last_block,
                    toBlock='latest'
                )

                for event in events:
                    logger.info(f"üéâ Evento BatchMinted detectado no bloco {event.blockNumber}")
                    recipients = event.args.recipients
                    amounts = event.args.amounts

                    for recipient, amount in zip(recipients, amounts):
                        try:
                            with transaction.atomic():
                                profile = UserProfile.objects.get(wallet_address__iexact=recipient)
                                token_amount = Decimal(str(amount / 10**18))
                                
                                # ‚úÖ Converte para Decimal antes de somar
                                profile.blockchain_balance += token_amount
                                profile.save(update_fields=['blockchain_balance'])
                                logger.info(f"‚úÖ Saldo atualizado para {recipient}: {profile.blockchain_balance} FBTK")
                        except UserProfile.DoesNotExist:
                            logger.warning(f"‚ùå Perfil n√£o encontrado para {recipient}")
                        except Exception as e:
                            logger.error(f"üö® Erro ao atualizar perfil {recipient}: {e}")

                    # Atualiza o √∫ltimo bloco processado
                    last_block = event.blockNumber + 1
                    settings.LAST_PROCESSED_BLOCK = last_block

                time.sleep(5)

            except Exception as e:
                logger.error(f"‚ùå Erro durante a escuta: {e}")
                time.sleep(10)
                service = BlockchainService(use_ws=False)  # Recria servi√ßo em caso de erro

    except Exception as e:
        logger.exception(f"‚ùå ERRO CR√çTICO ao iniciar escuta de eventos: {e}")
        raise
üß∞ Passo 2: Atualize o services.py para aceitar use_ws=False
üìÑ services.py
python


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
‚åÑ
class BlockchainService:
    def __init__(self, use_ws=False):
        # ‚úÖ Ajusta o provider com base em use_ws
        provider_url = settings.WEB3_WS_PROVIDER_URL if use_ws else settings.WEB3_HTTP_PROVIDER_URL
        
        if use_ws:
            self.w3 = Web3(Web3.WebSocketProvider(provider_url))
            logger.info("[BlockchainService] ‚úÖ Usando WebSocketProvider")
        else:
            self.w3 = Web3(Web3.HTTPProvider(provider_url))
            logger.info("[BlockchainService] üö´ Usando HTTPProvider")

        # ‚úÖ Valida conex√£o
        if not self.w3.is_connected():
            logger.error("‚ùå Falha ao conectar com o provider Ethereum")
            raise ConnectionError("N√£o foi poss√≠vel conectar ao provider Ethereum")

        # ‚úÖ Carrega contrato
        if hasattr(settings, 'CONTRACT_ADDRESS') and Web3.is_address(settings.CONTRACT_ADDRESS):
            if not self._load_contract():
                logger.warning("‚ö†Ô∏è Contrato n√£o carregado")
        else:
            logger.warning("‚ö†Ô∏è CONTRACT_ADDRESS n√£o definido ou inv√°lido")
üß™ Passo 3: Reinicie o worker do Celery com logs detalhados
bash


1
celery -A feedback_platform worker --loglevel=info --pool=solo --queues event_queue
‚û°Ô∏è Certifique-se de que ele est√° na raiz do projeto (feedback_platform/)

üßæ Passo 4: Execute manualmente no shell para validar eventos
bash


1
python manage.py shell
python


1
2
3
4
5
6
from blockchain.services import BlockchainService
service = BlockchainService(use_ws=False)

# Obter evento manualmente
events = service.contract.events.BatchMinted.get_logs(fromBlock='latest', toBlock='latest')
print("Eventos detectados:", len(events))
‚û°Ô∏è Se aparecerem eventos, o problema est√° na tarefa Celery

üß™ Passo 5: Crie uma transa√ß√£o para gerar evento
üìÑ No shell:
bash


1
python manage.py shell
python


1
2
from blockchain.tasks.rewards import process_reward_batch
process_reward_batch.delay()
‚û°Ô∏è Isso vai gerar um evento BatchMinted que seu listen_for_batch_mint_events pode capturar

üìã Resumo Final
‚úÖ
events.py
usa
get_logs()
em vez de
get_new_entries()
‚ùå Antes da corre√ß√£o
‚úÖ Valida
token_amount
como
Decimal
‚ùå Antes da corre√ß√£o
‚úÖ Worker do Celery escutando
event_queue
‚úÖ Sim
‚úÖ
BlockchainService
aceita
use_ws=False
‚ùå Ap√≥s valida√ß√£o
‚úÖ Logs mostrando eventos detectados
‚ùå Ap√≥s execu√ß√£o
‚úÖ Saldo local atualizado ap√≥s evento
‚ùå Ap√≥s valida√ß√£o

üöÄ Pr√≥ximos passos recomendados
Atualize o events.py com get_logs() e Decimal
Reinicie o worker do Celery com --queues event_queue
Cole o tx_hash no Etherscan para validar evento
Teste manualmente no shell se o evento √© detectado
Confira no worker se os logs de evento aparecem corretamente
Se ainda tiver d√∫vidas ou quiser integrar isso com front-end, posso te ajudar! üöÄ